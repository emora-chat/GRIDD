
/* Has Pet */

imp_trigger(init_ask_pet)
-> ask_pet_trigger ->
love(emora, c/picture())
type(c, group)
of(c, a/animal())
type(a, group)
h:<time(h/have(user, p/pet()), now)>
request_truth(emora, h)
h{"coldstart": 1}
;

time(have(user, p/pet()), now)
-> user_own_pet ->
time(o/possess(user, p), now)
user_aware(o)
;

t/time(h/have(user, p/pet()), now)
category(p)
-> q_ask_pet_type ->
op_more_info(p, h)
request(emora, p)
;

time(have(user, X/pet()), now)
-> user_has_pet ->
i:<i/property(X)>
request(emora, i)
;

prop_i/property(pt/pet())
prop_i{"confidence": 0}
req/request(emora, prop_i)
user_aware(req)
-> do_with_pet ->
pred:<like(user, pred/event(object())) with(pred, pt)>
request(emora, pred)
;

possess(user, pt/pet())
l/like(user, pred/event(object()))
l{"confidence": 0}
with(pred, pt)
req/request(emora, pred)
user_aware(req)
-> share_walk_dog ->
el/like(emora, walk(emora, emora_dog))
em/motivate(emora, healthy(emora))
cause(em, el)
;

energetic(X/pet())
possess(user, X)
-> energy_handful ->
t:<t/think(user, handful(X))>
request_truth(emora, t)
;

think(user, handful(X/pet()))
-> crazy_pet_event ->
e:<e/event(X) crazy(e)>
request(emora, e)
;



/* Does Not Have Pet */

time(h/have(user, p/pet()), now)
h{"confidence": -1}
-> not_have_pet ->
w:<time(w/want(user, p2/pet()), now)>
request_truth(emora, w)
;






/* Common Sense */

like(X/pet(), run(X))
->
energetic(X)
;

have(X/pet(), energy())
->
energetic(X)
;


like(X/pet(), nap(X))
->
lazy(X)
;

time(nap(X/pet()), habitual_present)
->
lazy(X)
;

time(like(X/pet(), fetch(X)), now)
->
playful(X)
healthy(X)
fun(X)
;

time(like(X/pet(), play(X)), now)
->
playful(X)
fun(X)
;

time(like(X/pet(), walk(X)), now)
->
healthy(X)
;

time(hide(X/pet()), habitual_present)
->
shy(X)
;

fat(X/pet())
->
lazy(X)
;

type(X/object(), park)
->
n:<locate(X, l/location()) n/near(l, h/home()) possess(user, h)>
request_truth(emora, n)

s:<s/size(X)>
request(emora, s)

love(emora, P/park())
type(P, group)
;

large(X/park())
->
C/crowded(X)
C{"confidence": -1}
;

small(X/park())
->
C/crowded(X)
;

Z/chew(X/pet(), Y/object())
possess(user, Y)
->
esympathy(emora, Z)
;


